use atprs_lex::lexicon::{
    LexArrayItem, LexObject, LexObjectProperty, LexRecord, LexToken, LexUserType,
    LexXrpcSubscription,
};
use heck::{ToPascalCase, ToSnakeCase};
use itertools::Itertools;
use std::collections::{HashMap, HashSet};
use std::io::{Result, Write};

pub(crate) struct CodeWriter {
    buf: Vec<u8>,
    schema_id: Option<String>,
}

impl CodeWriter {
    pub fn new(schema_id: Option<String>) -> Self {
        Self {
            buf: Vec::new(),
            schema_id,
        }
    }
    pub fn write_header(&mut self) -> Result<()> {
        writeln!(
            &mut self.buf,
            "// This file is generated by atprs-codegen. Do not edit."
        )
        .ok();
        if let Some(schema_id) = &self.schema_id {
            writeln!(
                &mut self.buf,
                "//! Definitions for the `{schema_id}` namespace."
            )?;
        }
        Ok(())
    }
    pub fn write_user_type(
        &mut self,
        name: &str,
        def: &LexUserType,
        defmap: &HashMap<String, &LexUserType>,
    ) -> Result<()> {
        // TODO
        writeln!(&mut self.buf)?;
        match def {
            LexUserType::XrpcQuery(_) | LexUserType::XrpcProcedure(_) => {
                writeln!(&mut self.buf, "// TODO")?;
            }
            _ => {
                if let Some(schema_id) = &self.schema_id {
                    let refname = if name == "main" {
                        schema_id.clone()
                    } else {
                        format!("{}#{}", schema_id, name)
                    };
                    writeln!(&mut self.buf, "// {refname}")?;
                };
                match def {
                    LexUserType::Record(record) => self.writer_record(name, record, defmap)?,
                    LexUserType::XrpcSubscription(subscription) => {
                        self.writer_subscription(name, subscription, defmap)?
                    }
                    LexUserType::Token(token) => self.write_token(name, token)?,
                    LexUserType::Object(object) => self.write_object(name, object, defmap)?,
                    LexUserType::String(string) => self.write_string(name, string)?,
                    _ => unimplemented!(),
                }
            }
        }
        Ok(())
    }
    pub fn write_mods(&mut self, mods: &[String]) -> Result<()> {
        for m in mods {
            if m == "lib" {
                continue;
            }
            writeln!(&mut self.buf, "pub mod {m};")?;
        }
        Ok(())
    }
    pub fn write_to_file(&mut self, file: &mut impl Write) -> Result<()> {
        file.write_all(&self.buf)
    }

    fn writer_record(
        &mut self,
        name: &str,
        record: &LexRecord,
        _defmap: &HashMap<String, &LexUserType>,
    ) -> Result<()> {
        if let Some(description) = &record.description {
            writeln!(&mut self.buf, "/// {}", description)?;
        }
        // TODO
        writeln!(&mut self.buf, "pub struct {} {{}}", name.to_pascal_case())?;
        Ok(())
    }
    fn writer_subscription(
        &mut self,
        name: &str,
        subscription: &LexXrpcSubscription,
        _defmap: &HashMap<String, &LexUserType>,
    ) -> Result<()> {
        if let Some(description) = &subscription.description {
            writeln!(&mut self.buf, "/// {}", description)?;
        }
        // TODO
        writeln!(&mut self.buf, "pub struct {} {{}}", name.to_pascal_case())?;
        Ok(())
    }
    fn write_token(&mut self, name: &str, token: &LexToken) -> Result<()> {
        if let Some(description) = &token.description {
            writeln!(&mut self.buf, "/// {}", description)?;
        }
        // TODO: enum?
        writeln!(&mut self.buf, "pub struct {};", name.to_pascal_case())?;
        Ok(())
    }
    fn write_object(
        &mut self,
        name: &str,
        object: &LexObject,
        _defmap: &HashMap<String, &LexUserType>,
    ) -> Result<()> {
        if let Some(description) = &object.description {
            writeln!(&mut self.buf, "/// {}", description)?;
        }
        let required = if let Some(required) = &object.required {
            required.iter().map(String::as_str).collect()
        } else {
            HashSet::new()
        };
        writeln!(
            &mut self.buf,
            "#[derive(serde::Serialize, serde::Deserialize)]"
        )?;
        writeln!(&mut self.buf, "pub struct {} {{", name.to_pascal_case())?;
        if let Some(properties) = &object.properties {
            for key in properties.keys().sorted() {
                self.write_object_property(key, &properties[key], &required)?;
            }
        }
        writeln!(&mut self.buf, "}}")?;
        Ok(())
    }
    fn write_object_property(
        &mut self,
        name: &str,
        property: &LexObjectProperty,
        required: &HashSet<&str>,
    ) -> Result<()> {
        match property {
            LexObjectProperty::Ref(r#ref) => {
                if let Some(description) = &r#ref.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                let (namespace, def) = r#ref
                    .r#ref
                    .split_once('#')
                    .unwrap_or((&r#ref.r#ref, "main"));
                let ref_type = if namespace.is_empty() {
                    def.to_pascal_case()
                } else {
                    format!(
                        "crate::{}::{}",
                        namespace.split('.').map(str::to_snake_case).join("::"),
                        def.to_pascal_case()
                    )
                };
                let field_type = if required.contains(name) {
                    ref_type
                } else {
                    format!("Option<{}>", ref_type)
                };
                writeln!(
                    &mut self.buf,
                    "    pub {}: {field_type},",
                    name.to_snake_case()
                )?;
            }
            LexObjectProperty::Union(ref_union) => {
                if let Some(description) = &ref_union.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO
                writeln!(&mut self.buf, "    // pub {}: ...,", name.to_snake_case())?;
            }
            LexObjectProperty::Bytes(bytes) => {
                if let Some(description) = &bytes.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO
                writeln!(&mut self.buf, "    // pub {}: ...,", name.to_snake_case())?;
            }
            LexObjectProperty::CidLink(cid_link) => {
                if let Some(description) = &cid_link.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO
                writeln!(&mut self.buf, "    // pub {}: ...,", name.to_snake_case())?;
            }
            LexObjectProperty::Array(array) => {
                if let Some(description) = &array.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                let item_type = match &array.items {
                    LexArrayItem::Boolean(_) => String::from("bool"),
                    LexArrayItem::Integer(_) => String::from("i32"),
                    LexArrayItem::String(_) => String::from("String"),
                    LexArrayItem::Unknown(_) => String::from(""), // TODO
                    LexArrayItem::Bytes(_) => String::from(""),   // TODO
                    LexArrayItem::CidLink(_) => String::from(""), // TODO
                    LexArrayItem::Blob(_) => String::from(""),    // TODO
                    LexArrayItem::Ref(r#ref) => {
                        let (namespace, def) = r#ref.r#ref.split_once('#').expect("invalid ref");
                        if namespace.is_empty() {
                            def.to_pascal_case()
                        } else {
                            format!(
                                "crate::{}::{}",
                                namespace.split('.').map(str::to_snake_case).join("::"),
                                def.to_pascal_case()
                            )
                        }
                    }
                    LexArrayItem::Union(_) => String::from(""), // TODO
                };
                let field_type = if required.contains(&name) {
                    format!("Vec<{}>", item_type)
                } else {
                    format!("Option<Vec<{}>>", item_type)
                };
                if item_type.is_empty() {
                    writeln!(
                        &mut self.buf,
                        "    // pub {}: Vec<...>",
                        name.to_snake_case()
                    )?;
                } else {
                    writeln!(
                        &mut self.buf,
                        "    pub {}: {field_type},",
                        name.to_snake_case()
                    )?;
                }
            }
            LexObjectProperty::Blob(blob) => {
                if let Some(description) = &blob.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO
                writeln!(&mut self.buf, "    // pub {}: ...,", name.to_snake_case())?;
            }
            LexObjectProperty::Boolean(boolean) => {
                if let Some(description) = &boolean.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                let field_type = if required.contains(&name) {
                    "bool"
                } else {
                    "Option<bool>"
                };
                writeln!(
                    &mut self.buf,
                    "    pub {}: {field_type},",
                    name.to_snake_case()
                )?;
            }
            LexObjectProperty::Integer(integer) => {
                if let Some(description) = &integer.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO: usize?
                let field_type = if required.contains(&name) {
                    "i32"
                } else {
                    "Option<i32>"
                };
                writeln!(
                    &mut self.buf,
                    "    pub {}: {field_type},",
                    name.to_snake_case()
                )?;
            }
            LexObjectProperty::String(string) => {
                if let Some(description) = &string.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO: enum?
                let field_type = if required.contains(&name) {
                    "String"
                } else {
                    "Option<String>"
                };
                writeln!(
                    &mut self.buf,
                    "    pub {}: {field_type},",
                    if name == "type" {
                        String::from("r#type")
                    } else {
                        name.to_snake_case()
                    }
                )?;
            }
            LexObjectProperty::Unknown(unknown) => {
                if let Some(description) = &unknown.description {
                    writeln!(&mut self.buf, "    /// {}", description)?;
                }
                // TODO
                writeln!(&mut self.buf, "    // pub {}: ...,", name.to_snake_case())?;
            }
        }
        Ok(())
    }
    fn write_string(&mut self, name: &str, string: &atprs_lex::lexicon::LexString) -> Result<()> {
        if let Some(description) = &string.description {
            writeln!(&mut self.buf, "/// {}", description)?;
        }
        // TODO: enum?
        writeln!(&mut self.buf, "pub struct {};", name.to_pascal_case())?;
        Ok(())
    }
}
